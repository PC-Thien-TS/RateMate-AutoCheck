#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Lightweight route discovery for Playwright E2E with optional test generation.

Usage examples:
  # Minimal: infer base_url + start path from URL and save JSON
  python tools/discover_routes.py --url https://example.com/login

  # Generate ready-to-run tests from discovered routes
  python tools/discover_routes.py --url https://example.com/login --emit-tests

  # Explicit base + start
  python tools/discover_routes.py --base https://example.com --start /login --emit-tests

Environment (optional):
  E2E_EMAIL / E2E_PASSWORD  Credentials to attempt login (clarifies protected routes)
  SITE                      Site key (default: derived from host)
  LOGIN_PATH                Known login path (optional override)

Output:
  - JSON at config/discovered/<site>.json (base_url, login_path, public, protected)
  - If --emit-tests, writes tests/generated/test_<site>_routes_generated.py
"""

from __future__ import annotations
import argparse
import json
import os
import re
import sys
import time
import urllib.parse as up
from collections import deque
from pathlib import Path

from playwright.sync_api import sync_playwright


def norm_base(url: str) -> str:
    p = up.urlparse(url)
    scheme = p.scheme or "https"
    netloc = p.netloc
    return f"{scheme}://{netloc}".rstrip("/")


def norm_path(path: str) -> str:
    if not path:
        return "/"
    if path.startswith("http://") or path.startswith("https://"):
        return up.urlparse(path).path or "/"
    return ("/" + path.lstrip("/")).split("#", 1)[0]


def guess_site(base: str) -> str:
    host = (up.urlparse(base).netloc or "site").lower()
    return re.sub(r"[^a-z0-9_\-]", "_", host)


def try_login(page, base_url: str, login_path: str | None, email: str | None, password: str | None):
    if not (email and password):
        return False
    # Heuristics for login form
    try:
        if login_path:
            page.goto(f"{base_url}{norm_path(login_path)}", wait_until="domcontentloaded", timeout=12_000)
        # Fill user & pass
        user = page.locator("input[type='email'], input[name*='user' i], input[id*='user' i], input[name*='account' i]").first
        pwd = page.locator("input[type='password']").first
        if user.count() == 0 or pwd.count() == 0:
            return False
        user.fill(email)
        pwd.fill(password)
        # Submit
        submit = page.get_by_role("button", name=re.compile(r"(login|log\s*in|sign\s*in|continue|submit)", re.I)).first
        if submit.count() == 0:
            submit = page.locator("button[type='submit'], input[type='submit']").first
        if submit.count():
            submit.click()
        page.wait_for_load_state("domcontentloaded", timeout=10_000)
        # If we are not at login page anymore assume success
        cur = page.url
        return (not re.search(r"/log[-_]?in|/sign[-_]?in", up.urlparse(cur).path, re.I))
    except Exception:
        return False


def _emit_tests(site: str, data: dict):
    from pathlib import Path
    tests_dir = Path("tests/generated")
    tests_dir.mkdir(parents=True, exist_ok=True)
    out_path = tests_dir / f"test_{site}_routes_generated.py"
    base_url = data.get("base_url", "")
    login_path = data.get("login_path", "/login")
    public = data.get("public") or []
    protected = data.get("protected") or []

    body = f"""# Auto-generated by tools/discover_routes.py
# -*- coding: utf-8 -*-
import re
import contextlib
import pytest
from pages.auth.login_page import LoginPage

SITE_KEY = {site!r}
BASE_URL_DISCOVERED = {base_url!r}
LOGIN_PATH_DISCOVERED = {login_path!r}
PUBLIC_ROUTES = {public!r}
PROTECTED_ROUTES = {protected!r}


def _maybe_login(page, base_url, login_path, email, password):
    if not (email and password):
        return
    lp = LoginPage(page, base_url, login_path)
    lp.goto(); lp.login(email, password)
    with contextlib.suppress(Exception):
        page.wait_for_load_state("domcontentloaded", timeout=8000)
        page.wait_for_timeout(200)


@pytest.mark.smoke
@pytest.mark.parametrize("path", PUBLIC_ROUTES)
def test_public_routes_open(new_page, site, base_url, path):
    if str(site).strip().lower() != SITE_KEY:
        pytest.skip("Different site")
    url = f"{{base_url.rstrip('/')}}{{path}}"
    try:
        new_page.set_default_navigation_timeout(30000)
        new_page.goto(url, wait_until="domcontentloaded")
        with contextlib.suppress(Exception):
            new_page.wait_for_timeout(200)
        assert new_page.url.startswith(base_url), f"Unexpected navigation for {{path}} -> {{new_page.url}}"
    except Exception as e:
        pytest.skip(f"unreachable {{url}}: {{e}}")


@pytest.mark.smoke
@pytest.mark.parametrize("path", PROTECTED_ROUTES)
def test_protected_routes_behavior(new_page, site, base_url, path):
    if str(site).strip().lower() != SITE_KEY:
        pytest.skip("Different site")
    import os
    email = os.getenv("E2E_EMAIL")
    password = os.getenv("E2E_PASSWORD")
    _maybe_login(new_page, base_url, LOGIN_PATH_DISCOVERED, email, password)
    url = f"{{base_url.rstrip('/')}}{{path}}"
    try:
        new_page.set_default_navigation_timeout(30000)
        new_page.goto(url, wait_until="domcontentloaded")
        with contextlib.suppress(Exception):
            new_page.wait_for_timeout(200)
        # If logged in, should not be at login page. If not logged in, allow redirect to login.
        at_login = bool(re.search(r"/(log[-_]?in|sign[-_]?in)(/|\\?|$)", new_page.url, re.I))
        if email and password:
            assert not at_login, f"Logged in but redirected to login for {{path}}: {{new_page.url}}"
        else:
            assert at_login or base_url in new_page.url, f"Expected login redirect for {{path}}"
    except Exception as e:
        pytest.skip(f"unreachable {{url}}: {{e}}")
"""
    out_path.write_text(body, encoding="utf-8")
    print(f"[discover] Wrote tests to {out_path}")


def main(argv: list[str] | None = None) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--url", help="Full start URL (infers base + start)")
    ap.add_argument("--base", help="Base URL (e.g., https://host)")
    ap.add_argument("--start", help="Start path (e.g., /login)")
    ap.add_argument("--max", type=int, default=80, help="Max pages to visit (default 80)")
    ap.add_argument("--depth", type=int, default=2, help="Max crawl depth (default 2)")
    ap.add_argument("--out", help="Output JSON path (default config/discovered/<site>.json)")
    ap.add_argument("--emit-tests", action="store_true", help="Also emit pytest module under tests/generated/")
    ap.add_argument("--emit-yaml", action="store_true", help="Also emit config/sites/<site>.yml with discovered data")
    ap.add_argument("--login-first", action="store_true", help="Attempt login before crawling (requires creds)")
    ap.add_argument("--nav-selectors", nargs="*", default=[
        # Traditional navs
        "aside a[href]",
        "nav a[href]",
        "[role='menuitem'][href]",
        "[data-test*=nav] a[href]",
        # Ionic/Angular style
        "ion-router-link",
        "ion-tab-button",
        "ion-item[routerLink]",
        "[routerLink]",
        "ion-button[routerLink]",
    ], help="Extra selectors to click/scan for navigation links")
    ap.add_argument("--allow", nargs="*", default=[], help="Allow-list regex (match path)")
    ap.add_argument("--deny", nargs="*", default=[], help="Deny-list regex (match path)")
    ap.add_argument("--screenshot-dir", help="Save screenshots on navigation error (directory)")
    args = ap.parse_args(argv)

    if args.url and (args.base or args.start):
        print("[discover] Use either --url or --base/--start, not both", file=sys.stderr)
        return 2

    if args.url:
        p = up.urlparse(args.url)
        base_url = f"{p.scheme}://{p.netloc}".rstrip("/")
        start = p.path or "/"
    else:
        if not args.base:
            print("[discover] Require --url or --base", file=sys.stderr)
            return 2
        base_url = norm_base(args.base)
        start = norm_path(args.start or "/")

    site = (os.getenv("SITE") or "").strip() or guess_site(base_url)
    login_path_env = os.getenv("LOGIN_PATH") or None
    ignore_patterns = [r"/logout", r"/sign[-_]?out", r"\.pdf$", r"\.jpg$", r"\.png$", r"\.svg$"]
    deny = ignore_patterns + (args.deny or [])
    ignore_re = re.compile("|".join(deny), re.I)
    allow_re = re.compile("|".join(args.allow), re.I) if args.allow else None

    email = os.getenv("E2E_EMAIL")
    password = os.getenv("E2E_PASSWORD")

    discovered_public: set[str] = set()
    discovered_protected: set[str] = set()

    visited: set[str] = set()
    q = deque([(start, 0)])

    screenshot_dir = None
    if getattr(args, 'screenshot_dir', None):
        screenshot_dir = Path(args.screenshot_dir)
        screenshot_dir.mkdir(parents=True, exist_ok=True)

    with sync_playwright() as pw:
        browser = pw.chromium.launch(headless=True)
        ctx = browser.new_context()
        page = ctx.new_page()

        # Try logging in once if requested or if start looks like login
        logged_in = False
        if args.login_first or re.search(r"/log[-_]?in|/sign[-_]?in", start, re.I):
            logged_in = try_login(page, base_url, login_path_env or start, email, password)
        if logged_in:
            print("[discover] Logged in successfully; will treat redirects to login as protected", file=sys.stderr)

        count = 0
        while q and count < args.max:
            path, depth = q.popleft()
            if path in visited or depth > args.depth:
                continue
            visited.add(path)
            count += 1
            try:
                resp = page.goto(f"{base_url}{path}", wait_until="domcontentloaded", timeout=12_000)
                status = resp.status if resp else None
                final_path = up.urlparse(page.url).path or "/"
                # Categorize
                is_login = bool(re.search(r"/log[-_]?in|/sign[-_]?in", final_path, re.I))
                if status in (401, 403) or is_login:
                    discovered_protected.add(path)
                else:
                    discovered_public.add(path)

                # Extract links from anchors
                hrefs = page.eval_on_selector_all(
                    "a[href]",
                    "nodes => nodes.map(n => n.getAttribute('href'))",
                )
                for href in hrefs or []:
                    if not href:
                        continue
                    if href.startswith("mailto:") or href.startswith("tel:"):
                        continue
                    u = up.urlparse(href)
                    if u.scheme and u.netloc and norm_base(href) != base_url:
                        continue  # external
                    pth = norm_path(u.path if u.scheme else href)
                    if ignore_re.search(pth):
                        continue
                    if allow_re and not allow_re.search(pth):
                        continue
                    if pth not in visited:
                        q.append((pth, depth + 1))

                # Extract Ionic/Angular router links
                ionic_hrefs = []
                try:
                    # ion-router-link elements may have an internal anchor; try attribute first
                    ionic_hrefs += page.eval_on_selector_all(
                        "ion-router-link",
                        "nodes => nodes.map(n => n.getAttribute('href') || n.getAttribute('routerLink'))",
                    ) or []
                except Exception:
                    pass
                try:
                    # Any element with [routerLink] attribute
                    ionic_hrefs += page.eval_on_selector_all(
                        "[routerLink]",
                        "nodes => nodes.map(n => n.getAttribute('routerLink'))",
                    ) or []
                except Exception:
                    pass
                # Normalize and enqueue
                for href in ionic_hrefs:
                    if not href:
                        continue
                    pth = norm_path(href)
                    if ignore_re.search(pth):
                        continue
                    if allow_re and not allow_re.search(pth):
                        continue
                    if pth not in visited:
                        q.append((pth, depth + 1))

                # Try to expand common navigation containers and re-scan
                for sel in args.nav_selectors:
                    try:
                        items = page.locator(sel)
                        n = min(items.count(), 20)
                        for i in range(n):
                            with contextlib.suppress(Exception):
                                items.nth(i).click(timeout=300)
                                page.wait_for_timeout(50)
                        # Re-scan links in nav area
                        hrefs2 = page.eval_on_selector_all(
                            sel,
                            "nodes => Array.from(new Set(nodes.flatMap(n => {\n"
                            "  const out = [];\n"
                            "  out.push(...Array.from(n.querySelectorAll('a[href]')).map(a => a.getAttribute('href')));\n"
                            "  out.push(...(n.getAttribute && n.getAttribute('href') ? [n.getAttribute('href')] : []));\n"
                            "  out.push(...(n.getAttribute && n.getAttribute('routerLink') ? [n.getAttribute('routerLink')] : []));\n"
                            "  return out;\n"
                            "})))",
                        )
                        for href in hrefs2 or []:
                            if not href:
                                continue
                            u = up.urlparse(href)
                            if u.scheme and u.netloc and norm_base(href) != base_url:
                                continue
                            pth = norm_path(u.path if u.scheme else href)
                            if ignore_re.search(pth):
                                continue
                            if allow_re and not allow_re.search(pth):
                                continue
                            if pth not in visited:
                                q.append((pth, depth + 1))
                    except Exception:
                        continue
            except Exception:
                # On navigation error consider path protected (may require auth) and continue
                discovered_protected.add(path)
                # Save a screenshot for diagnostics if requested
                if screenshot_dir:
                    safe = path.strip('/').replace('/', '_') or 'home'
                    pshot = screenshot_dir / f"err_{safe}.png"
                    with contextlib.suppress(Exception):
                        page.screenshot(path=str(pshot))
                continue

        browser.close()

    # Prepare output
    out = {
        "base_url": base_url,
        "login_path": login_path_env or start,
        "public": sorted(x for x in discovered_public if x.startswith("/")),
        "protected": sorted(x for x in discovered_protected if x.startswith("/")),
    }

    out_dir = Path("config/discovered")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = Path(args.out) if args.out else out_dir / f"{site}.json"
    out_path.write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[discover] Wrote {out_path}")
    print(json.dumps(out, ensure_ascii=False))
    if args.emit_tests:
        _emit_tests(site, out)
    if args.emit_yaml:
        # Write a compact site yaml file
        yml = {
            "base_url": out.get("base_url"),
            "auth_paths": {"login": out.get("login_path"), "register": out.get("login_path")},
            "routes": {"public": out.get("public") or [], "protected": out.get("protected") or []},
        }
        ydir = Path("config/sites")
        ydir.mkdir(parents=True, exist_ok=True)
        ypath = ydir / f"{site}.yml"
        try:
            import yaml as _yaml
            ypath.write_text(_yaml.safe_dump(yml, allow_unicode=True, sort_keys=False), encoding="utf-8")
        except Exception:
            # Fallback to JSON-like representation
            ypath.write_text(json.dumps(yml, ensure_ascii=False, indent=2), encoding="utf-8")
        print(f"[discover] Wrote YAML to {ypath}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

