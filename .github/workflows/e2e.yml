name: E2E

on:
  schedule:
    - cron: "*/10 * * * *"   
  workflow_dispatch: {}

concurrency:
  group: e2e
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      SITE: ratemate
      ENV: prod
      BASE_URL_PROD: https://store.ratemate.top
      LOGIN_PATH: /en/login
      REGISTER_PATH: /en/login
      # Ghi file trong container ở đường dẫn tuyệt đối để dễ copy ra
      JUNIT_XML:  /app/report/junit.xml
      REPORT_HTML: /app/report/e2e.html

    steps:
      - uses: actions/checkout@v4

      - name: Build test image
        run: docker build -t ratemate-tests .

      - name: Run tests (Chromium)
        env:
          # truyền tài khoản thật để login_success không bị skip
          E2E_EMAIL:     ${{ secrets.E2E_EMAIL }}
          E2E_PASSWORD:  ${{ secrets.E2E_PASSWORD }}
        run: |
          docker rm -f ratemate_e2e 2>/dev/null || true
          docker run --name ratemate_e2e -t --ipc=host --shm-size=1g --user 0:0 \
            -e SITE -e ENV -e BASE_URL_PROD -e LOGIN_PATH -e REGISTER_PATH \
            -e E2E_EMAIL -e E2E_PASSWORD \
            -e JUNIT_XML -e REPORT_HTML \
            ratemate-tests \
            bash -lc "mkdir -p /tmp/pytest_cache /tmp/test-results /app/report && \
              pytest -vv tests/auth tests/smoke/test_routes.py \
                --browser=chromium \
                -p no:pytest_excel \
                -o cache_dir=/tmp/pytest_cache \
                --output=/tmp/test-results \
                --screenshot=only-on-failure --video=off --tracing=retain-on-failure \
                -o junit_family=xunit2 --junitxml=\$JUNIT_XML \
                --html=\$REPORT_HTML --self-contained-html || true"

      - name: Copy report out (flatten, no nesting)
        if: always()
        run: |
          mkdir -p report
          # Dấu '/.' để copy NỘI DUNG thư mục /app/report ra ./report
          docker cp ratemate_e2e:/app/report/. ./report || true
          docker rm -f ratemate_e2e 2>/dev/null || true
          echo "== ls report =="
          ls -la report || true

      - name: Parse JUnit → summary
        id: sum
        if: always()
        run: |
          python - <<'PY'
          import os, json, pathlib, xml.etree.ElementTree as ET
          out = {}
          p = pathlib.Path("report/junit.xml")
          if p.exists():
              t = ET.parse(p).getroot()
              ts = t if t.tag.endswith('testsuite') else t.find('.//testsuite')
              def g(a): return int(ts.get(a, "0"))
              out = {
                  "total": g("tests"),
                  "fail": g("failures"),
                  "error": g("errors"),
                  "skip": g("skipped"),
                  "duration": float(ts.get("time","0")),
                  "fails": [],
              }
              for tc in ts.findall(".//testcase"):
                  fe = tc.find("failure") or tc.find("error")
                  if fe is not None:
                      name = f"{tc.get('classname','')}.{tc.get('name')}"
                      msg  = (fe.get("message") or "").strip()
                      txt  = (fe.text or "").strip()
                      out["fails"].append({"name": name, "reason": (msg or txt or 'No message')[:400]})
          # Xuất ra output cho bước sau
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write("summary_json<<EOF\n")
              fh.write(json.dumps(out, ensure_ascii=False))
              fh.write("\nEOF\n")
          PY

      - name: Send Telegram (message + report file)
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID:   ${{ secrets.TELEGRAM_CHAT_ID }}
          TELEGRAM_PROXY:     ${{ secrets.TELEGRAM_PROXY }}
          SUMMARY_JSON:       ${{ steps.sum.outputs.summary_json }}
        run: |
          python - <<'PY'
          import os, json, subprocess, xml.etree.ElementTree as ET, pathlib

          # ===== compose text =====
          raw = os.getenv("SUMMARY_JSON") or ""
          d = json.loads(raw) if raw else {}
          if not d:
              p = pathlib.Path("report/junit.xml")
              if p.exists():
                  t = ET.parse(p).getroot()
                  ts = t if t.tag.endswith('testsuite') else t.find('.//testsuite')
                  def g(a): return int(ts.get(a,"0"))
                  d = {"total": g("tests"), "fail": g("failures"), "error": g("errors"),
                       "skip": g("skipped"), "duration": float(ts.get("time","0")), "fails":[]}
                  for tc in ts.findall(".//testcase"):
                      fe = tc.find("failure") or tc.find("error")
                      if fe is not None:
                          name=f"{tc.get('classname','')}.{tc.get('name')}"
                          msg=(fe.get('message') or '').strip()
                          txt=(fe.text or '').strip()
                          d["fails"].append({"name":name,"reason":(msg or txt or 'No message')[:400]})
          total=d.get("total",0); fail=d.get("fail",0); err=d.get("error",0); skip=d.get("skip",0); dur=d.get("duration",0.0)
          status = "✅" if fail==0 and err==0 else "❌"
          lines = [
              f"{status} E2E Result: {total} tests | pass={total-fail-err-skip} fail={fail} error={err} skip={skip}",
              f"Duration: ~{dur:.1f}s",
              f"Run: {os.getenv('GITHUB_SERVER_URL','')}/{os.getenv('GITHUB_REPOSITORY','')}/actions/runs/{os.getenv('GITHUB_RUN_ID','')}",
          ]
          if d.get("fails"):
              lines.append("")
              lines.append("❗ Failed cases:")
              for f in d["fails"][:10]:
                  lines.append(f"• {f['name']}")
                  lines.append(f"  └─ {f['reason']}")
          text = "\n".join(lines)

          token = os.environ["TELEGRAM_BOT_TOKEN"]
          chat  = os.environ["TELEGRAM_CHAT_ID"]
          proxy = os.getenv("TELEGRAM_PROXY")

          # ===== 1) sendMessage =====
          url_msg   = f"https://api.telegram.org/bot{token}/sendMessage"
          payload_m = {"chat_id": chat, "text": text, "parse_mode": "HTML", "disable_web_page_preview": True}
          args_m = ["curl","-sS","-m","60","-X","POST","-H","Content-Type: application/json","-d",json.dumps(payload_m, ensure_ascii=False)]
          if proxy: args_m[1:1] = ["-x", proxy]
          args_m.append(url_msg)
          res_m = subprocess.run(args_m, capture_output=True, text=True)
          print("Telegram message:", res_m.stdout or res_m.stderr)

          # ===== 2) sendDocument (HTML report) =====
          # Ưu tiên e2e.html; nếu không có thì chọn file *.html bất kỳ trong report/
          report = pathlib.Path("report/e2e.html")
          if not report.exists():
              for cand in sorted(pathlib.Path("report").glob("*.html")):
                  report = cand
                  break

          if report.exists():
              url_doc = f"https://api.telegram.org/bot{token}/sendDocument"
              caption = f"E2E report • {total} tests | pass={total-fail-err-skip} fail={fail} error={err} skip={skip}"
              # multipart/form-data
              args_d = ["curl","-sS","-m","120","-X","POST",
                        "-F", f"chat_id={chat}",
                        "-F", f"caption={caption}",
                        "-F", f"document=@{report.as_posix()}"]
              if proxy: args_d[1:1] = ["-x", proxy]
              args_d.append(url_doc)
              res_d = subprocess.run(args_d, capture_output=True, text=True)
              print("Telegram document:", res_d.stdout or res_d.stderr)
          else:
              print("No HTML report found to send.")

          PY

      - name: Upload HTML report (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-report
          path: report/
