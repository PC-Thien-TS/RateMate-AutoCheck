name: E2E

on:
  schedule:
    - cron: "*/10 * * * *" # 10 ph√∫t/l·∫ßn
  workflow_dispatch:
    inputs:
      env:
        description: "ENV"
        type: choice
        options: [prod, staging]
        default: prod
      base_url:
        description: "Override BASE_URL (optional)"
        type: string
        default: ""
      browsers:
        description: "Browsers"
        type: choice
        options: ["chromium", "chromium+webkit"]
        default: "chromium"
      notify_on_success:
        description: "Always notify even if success?"
        type: boolean
        default: true

concurrency:
  group: e2e
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      SITE: ratemate
      ENV: ${{ inputs.env || 'prod' }}
      BASE_URL_PROD: ${{ inputs.base_url != '' && inputs.base_url || 'https://store.ratemate.top' }}
      LOGIN_PATH: /en/login
      REGISTER_PATH: /en/login
      JUNIT_XML: report/junit.xml
      # map secrets c≈© -> test d√πng E2E_*
      E2E_EMAIL: ${{ secrets.LOGIN_EMAIL }}
      E2E_PASSWORD: ${{ secrets.LOGIN_PASSWORD }}

    steps:
      - uses: actions/checkout@v4

      # ===== Build cache ƒë·ªÉ tƒÉng t·ªëc =====
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image (cached)
        uses: docker/build-push-action@v6
        with:
          context: .
          tags: ratemate-tests:latest
          load: true              # load v√†o local engine ƒë·ªÉ run
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ===== Health check base URL (fail nhanh n·∫øu site down) =====
      - name: Health check
        run: |
          set -e
          URL="${{ inputs.base_url != '' && inputs.base_url || 'https://store.ratemate.top' }}"
          echo "Checking $URL ..."
          code=$(curl -s -o /dev/null -w "%{http_code}" -m 15 "$URL")
          echo "HTTP $code"
          if [ "$code" -lt 200 ] || [ "$code" -ge 500 ]; then
            echo "Site not healthy"; exit 1
          fi

      # ===== ch·∫°y Chromium; th√™m WebKit n·∫øu ch·ªçn =====
      - name: Run tests in container
        run: |
          docker rm -f ratemate_e2e 2>/dev/null || true

          docker run --name ratemate_e2e -t --ipc=host --shm-size=1g --user 0:0 \
            -e SITE -e ENV -e BASE_URL_PROD -e LOGIN_PATH -e REGISTER_PATH \
            -e E2E_EMAIL -e E2E_PASSWORD \
            ratemate-tests \
            bash -lc "mkdir -p /tmp/pytest_cache /tmp/test-results /app/report && \
              pytest -vv tests/auth tests/smoke/test_routes.py \
                --browser=chromium \
                --reruns 1 --reruns-delay 2 \
                -n auto \
                -p no:pytest_excel \
                -o cache_dir=/tmp/pytest_cache \
                --output=/tmp/test-results \
                --screenshot=only-on-failure --video=off --tracing=retain-on-failure \
                --html=/app/report/e2e.html --self-contained-html \
                -o junit_family=xunit2 --junitxml=\$JUNIT_XML || true"

          if [ "${{ inputs.browsers }}" = "chromium+webkit" ]; then
            docker exec -t ratemate_e2e bash -lc \
              "pytest -vv tests/auth tests/smoke/test_routes.py \
                --browser=webkit \
                --reruns 1 --reruns-delay 2 \
                -n auto \
                -p no:pytest_excel \
                -o cache_dir=/tmp/pytest_cache \
                --output=/tmp/test-results \
                --screenshot=only-on-failure --video=off --tracing=retain-on-failure \
                --html=/app/report/e2e-wk.html --self-contained-html \
                -o junit_family=xunit2 --junitxml=\$JUNIT_XML.wk || true"
          fi

      - name: Pull artifacts
        run: |
          mkdir -p report
          docker cp ratemate_e2e:/app/report ./report || true
          docker cp ratemate_e2e:/tmp/test-results ./report/test-results || true
          docker rm -f ratemate_e2e 2>/dev/null || true

          # zip trace + screenshot n·∫øu c√≥
          if ls report/test-results/*/* 1>/dev/null 2>&1; then
            cd report
            zip -qr fail-artifacts.zip test-results -i '*trace.zip' -i '*.png' -i '*.webm' || true
            cd ..
          fi

      # ===== l∆∞u/ƒë·ªçc tr·∫°ng th√°i l·∫ßn tr∆∞·ªõc ƒë·ªÉ h·∫°n ch·∫ø spam =====
      - name: Restore e2e state
        id: st
        uses: actions/cache/restore@v4
        with:
          path: .e2e-state.json
          key: e2e-state

      - name: Parse JUnit ‚Üí summary
        id: sum
        run: |
          python - <<'PY'
          import os, json, pathlib, xml.etree.ElementTree as ET

          def parse_one(p):
            p = pathlib.Path(p)
            if not p.exists(): return None
            t = ET.parse(p).getroot()
            ts = t if t.tag.endswith('testsuite') else t.find('.//testsuite')
            if ts is None: return None
            gi = lambda k: int(ts.get(k,"0"))
            data = dict(total=gi("tests"), fail=gi("failures"), error=gi("errors"),
                        skip=gi("skipped"), duration=float(ts.get("time","0")), fails=[])
            for tc in ts.findall(".//testcase"):
              fe = tc.find("failure") or tc.find("error")
              if fe is not None:
                name=f"{tc.get('classname','')}.{tc.get('name')}"
                msg=(fe.get('message') or '').strip()
                txt=(fe.text or '').strip()
                data["fails"].append({"name":name,"reason":(msg or txt or 'No message')[:400]})
            return data

          merged = {"total":0,"fail":0,"error":0,"skip":0,"duration":0.0,"fails":[]}
          for fn in ("report/junit.xml","report/junit.xml.wk"):
            d = parse_one(fn)
            if not d: continue
            for k in ("total","fail","error","skip"): merged[k]+=d[k]
            merged["duration"] += d["duration"]
            merged["fails"].extend(d["fails"])

          # ghi output
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
            fh.write("summary_json<<EOF\n")
            fh.write(json.dumps(merged, ensure_ascii=False))
            fh.write("\nEOF\n")

          # vi·∫øt GitHub Job Summary
          t=merged; passed=t["total"]-t["fail"]-t["error"]-t["skip"]
          with open(os.environ["GITHUB_STEP_SUMMARY"],"a",encoding="utf-8") as f:
            f.write(f"**E2E:** {t['total']} tests | ‚úÖ {passed}  ‚ùå {t['fail']}  üß® {t['error']}  ‚è≠ {t['skip']}  in ~{t['duration']:.1f}s\n")
            if t["fails"]:
              f.write("\n<details><summary>Failed cases</summary>\n\n")
              for x in t["fails"]:
                f.write(f"- **{x['name']}**<br/> ‚Ü≥ {x['reason']}\n")
              f.write("\n</details>\n")
          PY

      - name: Send Telegram (message + html + fail bundle + ·∫£nh preview)
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID:   ${{ secrets.TELEGRAM_CHAT_ID }}
          TELEGRAM_PROXY:     ${{ secrets.TELEGRAM_PROXY }}
          TELEGRAM_PING_IDS:  ${{ secrets.TELEGRAM_PING_IDS }}
          SUMMARY_JSON:       ${{ steps.sum.outputs.summary_json }}
          NOTIFY_ON_SUCCESS:  ${{ inputs.notify_on_success }}
        run: |
          python - <<'PY'
          import os, json, subprocess, pathlib, glob

          # ƒë·ªçc summary
          d = json.loads(os.getenv("SUMMARY_JSON") or "{}")
          total=d.get("total",0); fail=d.get("fail",0); err=d.get("error",0); skip=d.get("skip",0); dur=d.get("duration",0.0)
          passed = total-fail-err-skip
          status_ok = (fail==0 and err==0)

          # ƒë·ªçc tr·∫°ng th√°i c≈©
          prev = {"ok": True}
          st_file = pathlib.Path(".e2e-state.json")
          if st_file.exists():
            try: prev.update(json.loads(st_file.read_text("utf-8")))
            except: pass

          # quy·∫øt ƒë·ªãnh c√≥ g·ª≠i kh√¥ng
          notify_on_success = (os.getenv("NOTIFY_ON_SUCCESS","true").lower()=="true")
          send_now = (not status_ok) or notify_on_success or (prev.get("ok") != status_ok)

          if not send_now:
            print("Skip Telegram (no change).")
          else:
            status = "‚úÖ" if status_ok else "‚ùå"
            lines=[]
            if not status_ok:
              pings = [s.strip() for s in (os.getenv("TELEGRAM_PING_IDS","") or "").split(",") if s.strip()]
              if pings:
                ping_txt = " ".join([f'<a href="tg://user?id={pid}">&#8203;</a>' for pid in pings])
                lines.append(f"‚ö†Ô∏è E2E failing {ping_txt}")
            lines += [
              f"{status} E2E Result: {total} tests | pass={passed} fail={fail} error={err} skip={skip}",
              f"Duration: ~{dur:.1f}s",
              f"Run: {os.getenv('GITHUB_SERVER_URL','')}/{os.getenv('GITHUB_REPOSITORY','')}/actions/runs/{os.getenv('GITHUB_RUN_ID','')}",
            ]
            if d.get("fails"):
              lines.append("")
              lines.append("‚ùó Failed cases:")
              for f in d["fails"][:10]:
                lines.append(f"‚Ä¢ {f['name']}")
                lines.append(f"  ‚îî‚îÄ {f['reason']}")

            text = "\n".join(lines)
            token=os.environ["TELEGRAM_BOT_TOKEN"]; chat=os.environ["TELEGRAM_CHAT_ID"]; proxy=os.getenv("TELEGRAM_PROXY")
            # send text
            url=f"https://api.telegram.org/bot{token}/sendMessage"
            payload={"chat_id":chat,"text":text,"parse_mode":"HTML","disable_web_page_preview":True}
            args=["curl","-sS","-m","60","-X","POST","-H","Content-Type: application/json","-d",json.dumps(payload, ensure_ascii=False)]
            if proxy: args[1:1]=["-x",proxy]
            print("Telegram(text)...")
            print(subprocess.run(args+[url],capture_output=True,text=True).stdout)

            # send HTML report(s)
            def send_doc(path, caption):
              if not pathlib.Path(path).exists(): return
              url=f"https://api.telegram.org/bot{token}/sendDocument"
              up=["curl","-sS","-m","120","-X","POST","-F",f"chat_id={chat}","-F",f"caption={caption}","-F",f"document=@{path}"]
              if proxy: up[1:1]=["-x",proxy]
              print(f"Telegram(doc:{path})...")
              print(subprocess.run(up+[url],capture_output=True,text=True).stdout)

            send_doc("report/e2e.html", f"E2E report ‚Ä¢ {total} tests | pass={passed} fail={fail} error={err} skip={skip}")
            send_doc("report/e2e-wk.html", "E2E WebKit report")

            # n·∫øu fail: g·ª≠i bundle + 1 ·∫£nh PNG ƒë·∫ßu ti√™n l√†m preview
            if not status_ok:
              send_doc("report/fail-artifacts.zip", f"E2E fail artifacts ‚Ä¢ {fail+err} failing test(s)")
              pngs = sorted(glob.glob("report/test-results/**/*.png", recursive=True))
              if pngs:
                url=f"https://api.telegram.org/bot{token}/sendPhoto"
                up=["curl","-sS","-m","60","-X","POST","-F",f"chat_id={chat}","-F",f"caption=First failure screenshot","-F",f"photo=@{pngs[0]}"]
                if proxy: up[1:1]=["-x",proxy]
                print("Telegram(photo)...")
                print(subprocess.run(up+[url],capture_output=True,text=True).stdout)

          # c·∫≠p nh·∫≠t tr·∫°ng th√°i m·ªõi & save v√†o cache
          st_file.write_text(json.dumps({"ok": status_ok}), encoding="utf-8")
          PY

      - name: Save e2e state
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .e2e-state.json
          key: e2e-state

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-report
          path: report/
          retention-days: 7
